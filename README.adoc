= debug_output
:source-highlighter: coderay
:coderay-linenums-mode: inline
:toc:

C++ debug output that's get's printed, unless `NDEBUG` is defined. +
Includes mutex-protected versions, that can be used with multithreading; as well as optional filename and linenumber output.

[[statement]]
== Recommended: Function-like Macro as standalone statement

Enable with `#define DEBUG_OUTPUT_FUNCLIKE_STATEMENT` (see <<usage>>).

* Basic usage:
+
[source,cpp]
----
D_OUT( << "hello" << " world" << std::endl); // "debug output"
----
+
You have to wrap the operators (`<<`) and their right-hand operands in brackets, since `D_OUT` is a function-like macro.
+
The preprocessor then generates
+
[cols="2,1"]
|===
a|
[source,cpp]
----
std::cout << "hello " << "world" << std::endl;
----
a|if `NDEBUG` is not defined +
  (i.e. debugging, so output debug-information)
|===
+
[cols="2,1"]
|===
a|
[source,cpp]
----
/* nothing */
----
a|if `NDEBUG` is defined +
  (i.e. not debugging, so no output)
|===
+
Why wrap the operators and operands in brackets?
+
The reason: sooner or later you'll find you'll need a mutex-protected print-version, that works in a multi-threaded program and secures the global `std::cout` resource: +

* Mutex-protected usage:
+
[source,cpp]
----
DM_OUT( << "hello" << " world" << std::endl); // "debug mutex out"
----
+
The macro knows how many chained operators (`<<`) and operands, are included in the scope of the mutex-protection, by requiring them to be wrapped in brackets.
+
This generates
+
[cols="2,1"]
|===
a|
[source,cpp]
----
 {                                                     \
    std::lock_guard<std::mutex> lock{debug_out_mutex}; \
    std::cout << "hello " << "world" << std::endl;     \
 }
----
a|if `NDEBUG` is not defined +
  (i.e. debugging, so output debug-information)
|===
+
[cols="2,1"]
|===
a|
[source,cpp]
----
/* nothing */
----
a|if `NDEBUG` is defined +
  (i.e. not debugging, so no output)
|===


=== Minor Limitations

Chaining out beyond the macro...
[source,cpp]
----
D_OUT( << "hello " << "world" << std::endl)   << "chaining does not work";
//                                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//                                          does not work (when NDEBUG defined)
----
does not work.

In other words: this specific `D_OUT` can only be used as a standalone statement. +
If you want chaining, then see below <<chaining>>.

=== Implementation Details

==== Non-Mutex Version

[cols="1,2"]
|===
|
*Macro when `NDEBUG` not defined* +
(debugging, so print output)

a|
[source,cpp]
----
#ifndef NDEBUG
#define D_OUT(...) (std::cout __VA_ARGS__)
#endif
----
|===


[cols="1,2"]
|===
|*Macro when `NDEBUG` defined* +
(not debugging, so print nothing)

a|
[source,cpp]
----
#ifdef NDEBUG
#define D_OUT(...) /* nothing */
#endif
----
|===



==== Mutex-protected Version

[cols="1,2"]
|===
|
*Macro when `NDEBUG` not defined* +
(debugging, so print output)

a|
[source,cpp]
----
#ifndef NDEBUG
#define DM_OUT(...)                                    \
 {                                                     \
    std::lock_guard<std::mutex> lock{debug_out_mutex}; \
    std::cout __VA_ARGS__;                             \
 }
#endif
----
[[mutex]]where `debug_output_header.h` has
[source,cpp]
----
#ifndef NDEBUG
#include <mutex>
extern std::mutex debug_out_mutex;
#endif
----
and `debug_output.cpp` has
[source,cpp]
----
#ifndef NDEBUG
#include <mutex>
std::mutex debug_out_mutex;
#endif
----
|===


[cols="1,2"]
|===
|*Macro when `NDEBUG` defined* +
(not debugging, so print nothing)

a|
[source,cpp]
----
#ifdef NDEBUG
#define DM_OUT(...) /* nothing */
#endif
----
|===









[[chaining]]
== Non-recommended: Function-like Macro as expression ("chaining behaviour")

Enable with `#define DEBUG_OUTPUT_FUNCLIKE_CHAINING` (see <<usage>>).

The difference with the <<statement,statement version>> above, is that here the chaining behaviour of `ostream` is possible.

But this version is less efficient (in that it requires a specific global `nullout` -- <<nullstream,reference>>), so I do not recommend this version, but instead the <<statement,version already shown above>>.

* Basic usage:
+
[source,cpp]
----
D_OUT(  << "hello" << " world" << std::endl) << "chain-it!"; // "debug output"
D_OUT() << "greetings" << std::endl;                         // "debug output"
----

* Mutex-protected usage:
+
[source,cpp]
----
DM_OUT( << "mutex " << "protected" << std::endl)    << "not mutex " << "protected" << std::endl;
//     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//            mutex protection                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//                                                             no mutex protection
----

=== Implementation Details

==== Non-Mutex Version

[cols="1,2"]
|===
|
*Macro when `NDEBUG` not defined* +
(debugging, so print output)

a|
[source,cpp]
----
#ifndef NDEBUG
#define D_OUT(...) (std::cout __VA_ARGS__)
#endif
----
|===


[cols="1,2"]
|===
|*Macro when `NDEBUG` defined* +
(not debugging, so print nothing)

a|
[source,cpp]
----
#ifdef NDEBUG
#define DOUT(...) nullout
#endif
----
[[nullstream]]where `debug_output_header.h` has
[source,cpp]
----
#ifdef NDEBUG

#include <ostream>

/// https://groups.google.com/d/msg/comp.lang.c++/HkEffd3Geb4/g8J6yTgSyQkJ
struct Nullstream: std::ostream {
  Nullstream(): std::ios(0), std::ostream(0) {}
};

extern Nullstream nullout;

#endif /* NDEBUG */
----
and `debug_output.cpp` has
[source,cpp]
----
#ifdef NDEBUG
/// https://groups.google.com/d/msg/comp.lang.c++/HkEffd3Geb4/g8J6yTgSyQkJ
struct Nullstream: std::ostream {
  Nullstream(): std::ios(0), std::ostream(0) {}
};
Nullstream nullout;
#endif
----
|===



==== Mutex-protected Version

[cols="1,2"]
|===
|
*Macro when `NDEBUG` not defined* +
(debugging, so print output)

a|
[source,cpp]
----
#ifndef NDEBUG
#define DM_OUT(...)                                          \
(static_cast<void>                                         \
 (                                                           \
   [&](){ std::lock_guard<std::mutex> lock{debug_out_mutex}; \
          std::cout __VA_ARGS__;                             \
        }()                                                  \
 ), std::cout)

/*
/// statement expressions (seem to be a GNU extension)
#define DM_OUT(...)                                    \
(({ std::lock_guard<std::mutex> lock{debug_out_mutex}; \
    static_cast<void>(std::cout __VA_ARGS__);          \
   }), std::cout)
*/
#endif /* NDEBUG */
----
with `debug_out_mutex` as shown <<mutex,above>>.
|===


[cols="1,2"]
|===
|*Macro when `NDEBUG` defined* +
(not debugging, so print nothing)

a|
[source,cpp]
----
#ifdef NDEBUG
#define DM_OUT(...) nullout
#endif
----
with `nullout` as shown <<nullstream,above>>
|===







[[deprecated]]
== Non-recommended: Macro (but not function-like)

Enable with `#define DEBUG_OUTPUT_NON_FUNCLIKE` (see <<usage>>).

If you really desperately want this +
[source,cpp]
----
DOUT << "hello" << " world" << std::endl;
----
i.e. no wrapping in brackets (and really don't need mutex-protection)... +
then see this method (adapted from here http://stackoverflow.com/a/11826787 )

[cols="1,2"]
|===
|*Macro when `NDEBUG` not defined* +
(debugging, so print output)

a|
[source,cpp]
----
#ifndef NDEBUG
#define DOUT (std::cout)
#endif
----
|===




[cols="1,2"]
|===
|*Macro when `NDEBUG` defined* +
(not debugging, so print nothing)

a|
[source,cpp]
----
#ifdef NDEBUG
#define DOUT             \
  if (debug_disabled)    \
  { /* nothing */        \
  }                      \
  else                   \
    Nullstream()    
#endif
----
With header `debug_output_header.h` having:
[source,cpp]
----
#ifdef NDEBUG
constexpr bool debug_disabled{true};

struct Nullstream: std::ostream {
  Nullstream(): std::ios(0), std::ostream(0) {}
};
#endif
----

|===


[[usage]]
== Usage

Set up global user settings by editing `debug_output_user.h`.
Here's a good example:
[source,cpp]
----
//////////////////
// User Settings
//////////////////

/* If you want to globally use a specific type of D_OUT (etc.) you can set that, 
   by setting one of the following 3 variants to uncommented.

   Alternatively you can leave all versions commented, and decide on a per-case basis what kind of
   D_OUT (etc.) you want. In that case do e.g. the following in cpp files
        #undef  DEBUG_OUTPUT_VARIANT
        #define DEBUG_OUTPUT_VARIANT   DEBUG_OUTPUT_FUNCLIKE_STATEMENT
        #include "debug_output.h"
        DOUT( << "hi" << std::endl);
   But that's one hell of a act, so just uncomment one of the following 3 variants
 */
#define DEBUG_OUTPUT_VARIANT DEBUG_OUTPUT_FUNCLIKE_STATEMENT
//#define DEBUG_OUTPUT_VARIANT DEBUG_OUTPUT_FUNCLIKE_CHAINING
//#define DEBUG_OUTPUT_VARIANT DEBUG_OUTPUT_NON_FUNCLIKE


/*
  If you  have left all 3 variants above commented (really!?),
  and plan to use DEBUG_OUTPUT_FUNCLIKE_CHAINING somewhere (on a per-case basis)
  then you need to uncomment the following line, in order to allow the linker to find the global called nullout
 */
//#define DEBUG_OUTPUT_GLOBAL_NULLOUT



/* Use mutex protection everywhere (within brackets) ? Even in normal D_OUT, D_ERR or D_LOG ?
   Then uncomment the following
*/
//#define DEBUG_OUT_MUTEX_EVERYWHERE



/* Are you sure you do NOT want to use mutex-protected versions called DM_OUT, DM_ERR or DM_LOG ?
   Then uncomment the following:
*/
#define DEBUG_OUT_NO_DM_MUTEX

/* With filename and linenumbers? Then uncomment the following
 */
//#define DEBUG_OUT_LINENO
----

Then just use this:
[source,cpp]
----
D_OUT( << "hello" << " world" << std::endl);
D_ERR( << "hello" << " world" << std::endl);
D_LOG( << "hello" << " world" << std::endl);
----

If you are in a multithreading environment, then just change the settings of `debug_output_user.h`, to have `DEBUG_OUT_MUTEX_EVERYWHERE` defined:
[source,cpp]
----
//////////////////
// User Settings
//////////////////

/* If you want to globally use a specific type of D_OUT (etc.) you can set that, 
   by setting one of the following 3 variants to uncommented.

   Alternatively you can leave all versions commented, and decide on a per-case basis what kind of
   D_OUT (etc.) you want. In that case do e.g. the following in cpp files
        #undef  DEBUG_OUTPUT_VARIANT
        #define DEBUG_OUTPUT_VARIANT   DEBUG_OUTPUT_FUNCLIKE_STATEMENT
        #include "debug_output.h"
        DOUT( << "hi" << std::endl);
   But that's one hell of a act, so just uncomment one of the following 3 variants
 */
#define DEBUG_OUTPUT_VARIANT DEBUG_OUTPUT_FUNCLIKE_STATEMENT
//#define DEBUG_OUTPUT_VARIANT DEBUG_OUTPUT_FUNCLIKE_CHAINING
//#define DEBUG_OUTPUT_VARIANT DEBUG_OUTPUT_NON_FUNCLIKE


/*
  If you  have left all 3 variants above commented (really!?),
  and plan to use DEBUG_OUTPUT_FUNCLIKE_CHAINING somewhere (on a per-case basis)
  then you need to uncomment the following line, in order to allow the linker to find the global called nullout
 */
//#define DEBUG_OUTPUT_GLOBAL_NULLOUT



/* Use mutex protection everywhere (within brackets)? Even in normal D_OUT, D_ERR or D_LOG ?
   Then uncomment the following
*/
#define DEBUG_OUT_MUTEX_EVERYWHERE



/* Are you sure you do NOT want to use mutex-protected versions called DM_OUT, DM_ERR or DM_LOG ?
   Then uncomment the following:
*/
#define DEBUG_OUT_NO_DM

/* With filename and linenumbers? Then uncomment the following
 */
//#define DEBUG_OUT_LINENO
----
